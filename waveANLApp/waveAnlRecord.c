/* waveAnlRecord.c */  
/*************************************************************************\
* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
* National Laboratory.
* Copyright (c) 2002 The Regents of the University of California, as
* Operator of Los Alamos National Laboratory.
* This file is distributed subject to a Software License Agreement found
* in the file LICENSE that is included with this distribution. 
\*************************************************************************/
/* waveAnlRecord.c - Record Support Routines for waveform analysis record */
/*
 *      Original Author: John Maclean
 *      Current Author:  Eric Norum
 *      Date:            3-14-04
 *
 *  The waveform analysis record is used to generate statistical information 
 *  on an array.
 *    Outputs generated by the record are: 
 *      maximum value
 *      minimum value
 *      peak to peak value
 *      mean value
 *      mean absolute deviation
 *      varience
 *      standard deviation
 *      Full Width Half Maximum 
 *
 *  Usr specified subroutines are also supported
 *
 * Modification Log:
 * -----------------
 * .00  6-13-00     jfm Original
 * .02  12-07-00    jfm Modified following requirements review
 * .03  03-01-02        jfm NDAs mods added. Cleaned up for release
 *                      improvements
 * .04  08-13-02    jfm Incorporating fixes from Peregrine McGehee and other 
 *                      improvements
 */

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <limits.h>

#include "dbDefs.h"
#include "registryFunction.h"
#include "errlog.h"
#include "alarm.h"
#include "dbStaticLib.h"
#include "dbAccess.h"
#include "dbScan.h"
#include "dbEvent.h"
#include "dbFldTypes.h"
#include "special.h"
#include "recSup.h"
#include "recGbl.h"
#define GEN_SIZE_OFFSET
#include "waveAnlRecord.h"
#undef  GEN_SIZE_OFFSET 
#include "epicsExport.h"

#define WANL_REC_DEBUG 00

/* Debug statments, always use together! */
#define BEGIN_DEBUG(level)   if( level <= warDebugLevel ) {
#define END_DEBUG            }
                                          
#define MIN_SAMPLE_SIZE 0
#define ARG_MAX 8
#define MIN_POINT_SIZE  0.000001

typedef long (*SUBFUNCPTR)(waveAnlRecord *);

/* Create RSET - Record Support Entry Table*/
#define report NULL
#define initialize NULL
static long init_record();
static long process();
static long special();
#define get_value NULL
static long cvt_dbaddr();
static long get_array_info();
static long put_array_info();
static long get_units();
static long get_precision();
#define get_enum_str NULL
#define get_enum_strs NULL
#define put_enum_str NULL
static long get_graphic_double();
#define get_control_double NULL
#define get_alarm_double NULL
 
rset waveAnlRSET={
    RSETNUMBER,
    report,
    initialize,
    init_record,
    process,
    special,
    get_value,
    cvt_dbaddr,
    get_array_info,
    put_array_info,
    get_units,
    get_precision,
    get_enum_str,
    get_enum_strs,
    put_enum_str,
    get_graphic_double,
    get_control_double,
    get_alarm_double
};
epicsExportAddress(rset,waveAnlRSET);
int warDebugLevel = 0;      /* Set your debug level */
epicsExportAddress(int,warDebugLevel);

/* local functions */
static void monitor(waveAnlRecord *pwvanl);
static long readInputs(waveAnlRecord *pwvanl, long nElements);
static double fwhm( waveAnlRecord *pwvanl, double peak, long peakI,double base);
static double interpolate(long lowerI, 
                          double lowerBound, 
                          double upperBound,
                          double value);
static long fetch_values(struct waveAnlRecord *pwvanl);
static long findSub(waveAnlRecord *pwvanl, 
                    char          *subName, 
                    SUBFUNCPTR    *psubAddr); 
long findIndex(waveAnlRecord *pwvanl, long val);
void findRegionInterest(waveAnlRecord *pwvanl);                    


/************************************************************/
/*                                                          */
/* Record support routines                                  */
/*                                                          */
/************************************************************/
static long init_record(void *precord,int pass)
{
  waveAnlRecord *pwvanl = (waveAnlRecord *)precord;
  SUBFUNCPTR    sub_addr;
  long          status = 0;
  struct        link *plink;
  int           i;
  double        *pvalue;

  if (pass==1){
  
    /* Init main input link */
    pwvanl->bptr = (double *)dbCalloc(pwvanl->nelm,sizeof(double));
    if(pwvanl->bptr == NULL) {
      recGblRecordError(S_rec_outMem,(void *)pwvanl,"waveAnl: init_record");
      return(S_rec_outMem);
    }
    pwvanl->val = pwvanl->bptr;
     
    /* Take care of the parameters in case the input links are constant */ 
    recGblInitConstantLink(&pwvanl->xrsl,DBF_DOUBLE,&pwvanl->xres);
    recGblInitConstantLink(&pwvanl->xofl,DBF_DOUBLE,&pwvanl->xoff);
    recGblInitConstantLink(&pwvanl->blol,DBF_DOUBLE,&pwvanl->blof);

    /* Now take care of X axis array */ 
    pwvanl->xptr = (double *)dbCalloc(pwvanl->nelm,sizeof(double));
    if(pwvanl->xptr == NULL) {
      recGblRecordError(S_rec_outMem,(void *)pwvanl,"waveAnl: init_record");
      return(S_rec_outMem);
    }
    /* Set up X axis */
    if(!pwvanl->xres) pwvanl->xres = 1;
    for( i=0 ; i < pwvanl->nelm ; i++ ) {
      *(pwvanl->xptr + i) = i * pwvanl->xres + pwvanl->xoff;
    }
    pwvanl->oxrs = pwvanl->xres;
    pwvanl->oxof = pwvanl->xoff;
    
    /* Set up region of interest */
    findRegionInterest(pwvanl);

    /* Init User inputs */
    plink = &pwvanl->inpa;
    pvalue = &pwvanl->a;
    for(i=0; i<ARG_MAX; i++, plink++, pvalue++) {
      if (plink->type==CONSTANT) {
        recGblInitConstantLink(plink,DBF_DOUBLE,pvalue);
      }
    }
    
    /* Find user subroutine, if it exists */
    if( !status ) {
      if( pwvanl->snam[0] != '\0' ) {
          status = findSub( pwvanl, pwvanl->snam, (SUBFUNCPTR *)&pwvanl->sadr); 
      }
      if(status) {
        recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
        pwvanl->sadr = NULL;
      }
    }

    /* Find the user initialisation routine and call it if there is one */
    if(strlen(pwvanl->inam)!=0) {
        status = findSub(pwvanl, pwvanl->inam, &sub_addr);
        if(!status) {
          status = (*sub_addr)(pwvanl); 
          if (status < 0)
              recGblSetSevr(pwvanl, SOFT_ALARM, pwvanl->brsv);
      }
      else {
        recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
      }
    }
  }
  return(status);
}

static long process(void *precord)
{
  waveAnlRecord *pwvanl = (waveAnlRecord *)precord;
  long          status = 0;
  unsigned long i;
  long          nRequest, nSamples;
  unsigned long maxI = 0;      /* index of max value */
  double        sum, ep, diff;
  
  pwvanl->pact = TRUE;
  if(!dbIsLinkConnected(&pwvanl->inp) 
    || dbGetNelements(&pwvanl->inp,&nRequest)
    || nRequest<=0) {
    recGblSetSevr(pwvanl,READ_ALARM,INVALID_ALARM);
  } 
  else {
    recGblGetTimeStamp(pwvanl);

    status = readInputs(pwvanl, nRequest);
    if(status) {
      return(status);
    }
    
    /* recalculate X array if neccessary */
    if(pwvanl->xres != pwvanl->oxrs || pwvanl->xoff != pwvanl->oxof) {
      for( i=0 ; i < pwvanl->nelm ; i++ ) {
        *(pwvanl->xptr + i) = i * pwvanl->xres + pwvanl->xoff;
      }
      pwvanl->oxrs = pwvanl->xres;
      pwvanl->oxof = pwvanl->xoff;
    }
    
    /* Execute user subroutine, if there is one, 1st call*/
    if( pwvanl->snam[0] != '\0' &&  pwvanl->sadr != NULL) {
        pwvanl->pass = 0;
        status = fetch_values(pwvanl);
      if(!status){
          status = ((SUBFUNCPTR)(pwvanl->sadr))(pwvanl);
        if( status < 0 ) {
          recGblSetSevr(pwvanl, SOFT_ALARM, pwvanl->brsv);
        }
      }
      else {
        errlogPrintf("waveAnlRecord: link error\n");
      }
    }

    /* First pass, calc mean, min, max, pk to pk.                       */
    /* Region of interest is set up by init_record or special routines. */
    /* Intialise sum, min and max to first element of array.            */
    nSamples    =   pwvanl->enix - pwvanl->bgix + 1; 
    sum         = *(pwvanl->bptr + pwvanl->bgix);
    pwvanl->min = *(pwvanl->bptr + pwvanl->bgix);
    pwvanl->max = *(pwvanl->bptr + pwvanl->bgix);
    /* start loop at 2nd item as we've already initialised vars */
    for(i = pwvanl->bgix + 1; i <= pwvanl->enix ; i++) {
      BEGIN_DEBUG(20)
        printf("value[%ld] = %e\n", i, *(pwvanl->bptr + i));
      END_DEBUG
      sum += *(pwvanl->bptr + i);
      if(pwvanl->min > *(pwvanl->bptr + i)) {
        pwvanl->min = *(pwvanl->bptr + i);
      }
      if(pwvanl->max < *(pwvanl->bptr + i)) {
        pwvanl->max = *(pwvanl->bptr + i);
        maxI = i;
      }
    }
    pwvanl->mean = sum / nSamples;
    pwvanl->pkpk = pwvanl->max - pwvanl->min;
    
    BEGIN_DEBUG(20)
      printf("mean = %e\n", pwvanl->mean);
      printf("min = %e, max = %e\n", pwvanl->min, pwvanl->max);
    END_DEBUG
    
    /* second pass, calc mad, var sdev */
    pwvanl->madv = 0;
    pwvanl->var = 0;
    ep = 0;
    for(i = pwvanl->bgix; i <= pwvanl->enix ; i++) {
      diff =  *(pwvanl->bptr + i) - pwvanl->mean;         
      ep += diff;
      pwvanl->madv += fabs(diff);
      pwvanl->var += diff * diff;
    }
    pwvanl->madv /= nSamples;
    pwvanl->var = (pwvanl->var - ep*ep / nSamples) / (nSamples - 1);
    pwvanl->sdev = sqrt(pwvanl->var);
    
    pwvanl->fwhm = fwhm(pwvanl, pwvanl->max, maxI, pwvanl->blof) / pwvanl->xres;

    BEGIN_DEBUG(30)
          printf("nelm = %ld\n",pwvanl->nelm);  
      for(i=0; i < pwvanl->nelm ; i++) {
        printf("Element [%ld] = %f\txval = %f\n",i, *(pwvanl->bptr + i),
                *(pwvanl->xptr + i) );
      }
    END_DEBUG    
    BEGIN_DEBUG(50)
      printf("Min = %f, Max = %f, Mean = %f\n", pwvanl->min,pwvanl->max,
             pwvanl->mean);
      printf("mad = %f, var = %f, sdev = %f\n",pwvanl->madv ,pwvanl->var,
              pwvanl->sdev);
    END_DEBUG    

  }
  
  /* Execute user subroutine, if there is one, 2nd call*/
  if( pwvanl->snam[0] != '\0' &&  pwvanl->sadr != NULL) {
      pwvanl->pass = 1;
    status = ((SUBFUNCPTR)(pwvanl->sadr))(pwvanl); 
    if( status < 0 ) {
      recGblSetSevr(pwvanl, SOFT_ALARM, pwvanl->brsv);
    }
  }

  /* Done the dirty work, now finish the housekeeping */
  pwvanl->udf = FALSE;
  recGblResetAlarms(pwvanl);
  monitor(pwvanl);
  /* process the forward scan link record */
  recGblFwdLink(pwvanl);
  pwvanl->pact = FALSE;
  return(status);
}

static long get_units(DBADDR *paddr, char *units)
{
  waveAnlRecord *pwvanl=(waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
    case waveAnlRecordMAX:
    case waveAnlRecordMIN:
    case waveAnlRecordMEAN:
    case waveAnlRecordVAR:
    case waveAnlRecordSDEV:
    case waveAnlRecordMADV:
    case waveAnlRecordFWHM:
    case waveAnlRecordPKPK:
    case waveAnlRecordVALA:
    case waveAnlRecordVALB:
    case waveAnlRecordVALC:
    case waveAnlRecordVALD:
    case waveAnlRecordVALE:
    case waveAnlRecordVALF:
    case waveAnlRecordVALG:
    case waveAnlRecordVALH:
    case waveAnlRecordA:
    case waveAnlRecordB:
    case waveAnlRecordC:
    case waveAnlRecordD:
    case waveAnlRecordE:
    case waveAnlRecordF:
    case waveAnlRecordG:
    case waveAnlRecordH: 
      strncpy(units,pwvanl->eguy,DB_UNITS_SIZE);
      break;
    case waveAnlRecordXRES:
    case waveAnlRecordXOFF:
    case waveAnlRecordXPTR:
      strncpy(units,pwvanl->egux,DB_UNITS_SIZE);
      break;
  }     
  return(0);
}

static long get_precision(DBADDR *paddr, long *precision)
{
  waveAnlRecord *pwvanl=(waveAnlRecord *)paddr->precord;

  *precision = pwvanl->prec;
  recGblGetPrec(paddr,precision);
  return(0);
}

static long get_graphic_double(DBADDR *paddr,struct dbr_grDouble *pgd)
{
  waveAnlRecord *pwvanl=(waveAnlRecord *)paddr->precord;
  int       fieldIndex = dbGetFieldIndex(paddr);

  if ( fieldIndex == waveAnlRecordVAL
    || fieldIndex == waveAnlRecordMAX
    || fieldIndex == waveAnlRecordMIN
    || fieldIndex == waveAnlRecordMEAN
    || fieldIndex == waveAnlRecordVAR
    || fieldIndex == waveAnlRecordSDEV
    || fieldIndex == waveAnlRecordMADV
    || fieldIndex == waveAnlRecordFWHM
    || fieldIndex == waveAnlRecordPKPK
    || fieldIndex == waveAnlRecordVALA
    || fieldIndex == waveAnlRecordVALB
    || fieldIndex == waveAnlRecordVALC
    || fieldIndex == waveAnlRecordVALD
    || fieldIndex == waveAnlRecordVALE
    || fieldIndex == waveAnlRecordVALF
    || fieldIndex == waveAnlRecordVALG
    || fieldIndex == waveAnlRecordVALH
    || fieldIndex == waveAnlRecordA
    || fieldIndex == waveAnlRecordB
    || fieldIndex == waveAnlRecordC
    || fieldIndex == waveAnlRecordD
    || fieldIndex == waveAnlRecordE
    || fieldIndex == waveAnlRecordF
    || fieldIndex == waveAnlRecordG
    || fieldIndex == waveAnlRecordH ) {
      pgd->upper_disp_limit = pwvanl->hory;
      pgd->lower_disp_limit = pwvanl->lory;
  } else {
    if ( fieldIndex == waveAnlRecordXRES
      || fieldIndex == waveAnlRecordXOFF
      || fieldIndex == waveAnlRecordXPTR ) {
        pgd->upper_disp_limit = pwvanl->horx;
        pgd->lower_disp_limit = pwvanl->lorx;
    } else {
        recGblGetGraphicDouble(paddr,pgd);
      }
  }
  return(0);
}

static long cvt_dbaddr(DBADDR *paddr)
{
  waveAnlRecord *pwvanl = (waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
      paddr->pfield = (void *)(pwvanl->val);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      paddr->field_size = sizeof(DBF_DOUBLE);
      paddr->dbr_field_type = DBF_DOUBLE;
      BEGIN_DEBUG(30)
        printf("cvt_dbaddr:waveAnlRecordVAL pfld = %ld, nel %ld\n",
          (long) pwvanl->val, pwvanl->nelm);
      END_DEBUG
      break;
    case waveAnlRecordXPTR:
      paddr->pfield = (void *)(pwvanl->xptr);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      paddr->field_size = sizeof(DBF_DOUBLE);
      paddr->dbr_field_type = DBF_DOUBLE;
      BEGIN_DEBUG(30)
            printf("cvt_dbaddr:waveAnlRecordXPTR\n");
      END_DEBUG      
      break;
    default:
      paddr->pfield = (void *)(pwvanl->bptr);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      BEGIN_DEBUG(30)
          printf("cvt_dbaddr:default\n");
      END_DEBUG      
    }     
    return(0);
}

static long get_array_info(DBADDR *paddr, long *no_elements, long *offset)
{
  waveAnlRecord *pwvanl = (waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
      paddr->pfield = (void *)(pwvanl->val);
      *no_elements =  pwvanl->nuse;
      *offset = 0;
      BEGIN_DEBUG(30)
           printf("get_array_info:waveAnlRecordVAL nuse=%ld\n",pwvanl->nuse);
      END_DEBUG      
      break;
    case waveAnlRecordXPTR:
      paddr->pfield = (void *)(pwvanl->xptr);
      *no_elements =  pwvanl->nuse;
      *offset = 0;
      BEGIN_DEBUG(30)
          printf("get_array_info:waveAnlRecordXPTR nuse=%ld\n",pwvanl->nuse);
      END_DEBUG      
      break;
    default:
      BEGIN_DEBUG(30)
          printf("get_array_info:default\n");
      END_DEBUG      
      *no_elements = 0;
      *offset = 0;
  }     
    return(0);
}

static long put_array_info(DBADDR *paddr, long nNew)
{
  waveAnlRecord *pwvanl = (waveAnlRecord *)paddr->precord;
  
  if(nNew > pwvanl->nelm) {
    pwvanl->nuse = pwvanl->nelm;
  }
  else  {
    pwvanl->nuse = nNew;
  } 
  return(0);
}

/* Find new subroutine name if it exisists and put address in sadr  */
/* Error if routine doesn't exist                                                                       */
static long special(DBADDR *paddr, int after)
{
  waveAnlRecord   *pwvanl = (waveAnlRecord *)(paddr->precord);
  int                 special_type = paddr->special;
  long            status = 0;

  if(!after) return(0);

  switch(special_type) {
    case(SPC_MOD):
      switch(dbGetFieldIndex(paddr)) {
        case waveAnlRecordSNAM:
            status = findSub( pwvanl, pwvanl->snam, (SUBFUNCPTR *)&pwvanl->sadr); 
          if(status) {
            pwvanl->sadr = NULL;
            recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
            recGblRecordError(S_db_BadSub,(void *)pwvanl,
                          "waveAnlRecord:special");
            status = S_db_BadSub;
          }  
          break;
        case waveAnlRecordBGRI:
        case waveAnlRecordENRI:
          /* Set up region of interest */
          findRegionInterest(pwvanl);
          break;
        default: {
        recGblDbaddrError(S_db_badChoice,paddr,"waveAnl: special");
        status = S_db_badChoice;
        }
      }
      break;
    default: {
      recGblDbaddrError(S_db_badChoice,paddr,"waveAnl: special");
      status = S_db_badChoice;
    }
  }
  recGblResetAlarms(pwvanl);
  return(status);
}

/************************************************************/
/*                                                          */
/* Local routines                                           */
/*                                                          */
/************************************************************/

static void monitor(struct waveAnlRecord *pwvanl) {
  unsigned short    monitor_mask;
  double *pval; /* structure of the link field  */
  int         i;

  monitor_mask = recGblResetAlarms(pwvanl);
  monitor_mask |= (DBE_VALUE|DBE_LOG);
  BEGIN_DEBUG(30)
    printf("waveAnl:monitor run. Mask = %d\n", monitor_mask);
  END_DEBUG      
  if(monitor_mask) {
    db_post_events(pwvanl,pwvanl->bptr,monitor_mask);
    db_post_events(pwvanl,pwvanl->xptr,monitor_mask);
    db_post_events(pwvanl,pwvanl->val,monitor_mask);
    db_post_events(pwvanl,&pwvanl->min,monitor_mask);
    db_post_events(pwvanl,&pwvanl->max,monitor_mask);
    db_post_events(pwvanl,&pwvanl->mean,monitor_mask);
    db_post_events(pwvanl,&pwvanl->madv,monitor_mask);
    db_post_events(pwvanl,&pwvanl->var,monitor_mask);
    db_post_events(pwvanl,&pwvanl->sdev,monitor_mask);
    db_post_events(pwvanl,&pwvanl->fwhm,monitor_mask);
    db_post_events(pwvanl,&pwvanl->pkpk,monitor_mask);
    if( pwvanl->snam[0] != '\0' ) {
      /* Only need to post these if usr subrtn is executed */
      pval  = &pwvanl->vala;
      for(i=0; i<ARG_MAX; i++, pval++) {
        db_post_events(pwvanl,pval,monitor_mask);
      }
    }
  }
  return;
}

/* Get data from input links                                 */
/* Allocate a new size buffer if required                    */
static long readInputs(waveAnlRecord *pwvanl, long nElements) {
  long status = 0;

  if(nElements > pwvanl->nelm) {
    nElements = pwvanl->nelm;
  }
  /* Get the merchandise in to the data buffer */
  status = dbGetLink(&pwvanl->inp, DBF_DOUBLE, pwvanl->bptr, 0, &nElements);
  if(status || nElements <= 0) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
  }
  pwvanl->nuse = pwvanl->nelm;
  
  /* Read other links */
  status=dbGetLink(&pwvanl->blol,DBR_DOUBLE, &pwvanl->blof,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
    }
  status=dbGetLink(&pwvanl->xrsl,DBR_DOUBLE, &pwvanl->xres,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
    }
  /* Make sure we don't divide by zero */
  if(pwvanl->xres == 0) {
    pwvanl->xres = 1;
  }
  status=dbGetLink(&pwvanl->xofl,DBR_DOUBLE, &pwvanl->xoff,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
    }
  return(status);
}  

/* calc fwhm in terms of array indicies, compliments of nda */
static double fwhm(waveAnlRecord *pwvanl, double peak, long peakI,double base)
{
  double hmVal;
  long hm1, hm2, i;
  double *profile;
  double fwhm1, fwhm2;
  
  if(pwvanl->thld <= 0 || pwvanl->thld >= 1) {
    pwvanl->thld = 0.5;            /* default to half max */
    recGblRecordError(S_db_badField,(void *)pwvanl,
    "waveAnl: fwhm: thld must be between 0 and 1. Replaced with default");
  }
  
  /* Calc 'half max' value. */
  hmVal = (peak - base) * pwvanl->thld + base;

  hm1 = pwvanl->bgix;
  hm2 = pwvanl->enix - 1; 
  profile = pwvanl->bptr; 
  
  /* find index at which curve passes hmVal */
  for (i=peakI; (i >= pwvanl->bgix) && (*(profile + i) > hmVal); i--) {
    hm1 = i;
  }
  for (i=peakI; (i < pwvanl->enix - 1) && (*(profile + i) > hmVal); i++) {
    hm2 = i;
  }
  
  fwhm1 = pwvanl->bgix;
  fwhm2 = pwvanl->enix - 1;   

  if(hm1 != pwvanl->bgix) {
    fwhm1 = interpolate(hm1 - 1, *(profile + hm1 - 1), *(profile + hm1), hmVal);
  }
  if(hm2 != (pwvanl->enix - 1)) {
    fwhm2 = interpolate(hm2 , *(profile + hm2), *(profile + hm2+1), hmVal);
  }

  BEGIN_DEBUG(50)
    printf("pk %f, pkI %ld, base %f, hmVal %f hm1 %ld, hm2 %ld, fwhm1 %f, fwhm2 %f\n",
          peak, peakI, base, hmVal, hm1, hm2, fwhm1, fwhm2);
  END_DEBUG  
  return(fwhm2 - fwhm1);
}

/* Interpolate between lowerBound and upperBound to find psuedo index value */
/* at which hm value occurs. Compliments of nda                                */
static double interpolate(long lowerI, 
                          double lowerBound, 
                          double upperBound,
                          double value)
{
  double result, range, delta;
  
  result = lowerI;
  range = upperBound - lowerBound;
  /* When no reasonable profile is present, guard against overflow/underflow */
  /* valid profile data is assumed to have at least 1 count between points */
  if (range > MIN_POINT_SIZE) {
    delta = (value - lowerBound)/range;
    result += delta;
  }
  return (result);
}

/* Get the values on INPA, INPB,... for the user subroutine    */
static long fetch_values(struct waveAnlRecord *pwvanl) {
  struct link *plink; /* structure of the link field  */
  double      *pvalue;
  int         i;
  long        status;

  plink  = &pwvanl->inpa;
  pvalue = &pwvanl->a;  
  for(i=0; i<ARG_MAX; i++, plink++, pvalue++) {
    status=dbGetLink(plink,DBR_DOUBLE, pvalue,NULL,NULL);
    if (!RTN_SUCCESS(status)) 
      return(-1);
  }
  return(0);
}

/* Find subroutine namwe given by *subName                */
/* If it exists, put subroutine address in *psubAddr      */
/* Else generate an error                                 */
static long findSub(waveAnlRecord *pwvanl, char *subName, SUBFUNCPTR *psubAddr)
{
    long status = 0;
    *psubAddr = (SUBFUNCPTR)registryFunctionFind(subName);
    if(*psubAddr == NULL) {
        recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
        status = S_db_BadSub; 
    }
    return(status);
}

/* find index value of an array with item value <= than         */
/* given value. Assumes array contents are in ascending order   */
long findIndex(waveAnlRecord *pwvanl, long val) {
  unsigned long i;
  long retIdx = 0;
  
  for( i=0; i < pwvanl->nelm  && *(pwvanl->xptr + i) <= val; i++) {
    retIdx = i;
    BEGIN_DEBUG(40)
      printf("nelm = %ld;  xptr = %f;  retIdx = %ld,  val =%ld\n", pwvanl->nelm,
       *(pwvanl->xptr + i), retIdx, val); 
    END_DEBUG
  }
  return(retIdx);
}

/* Find indicies of region of interest */
/* Makes sure that bounds are legal    */
void findRegionInterest(waveAnlRecord *pwvanl) {
  long temp;

  pwvanl->bgix = findIndex(pwvanl, pwvanl->bgri);

  /* if enri is not set default to use whole array */
  if(pwvanl->enri == 0) {
    pwvanl->enix = pwvanl->nelm - 1;
  }
  else {
    pwvanl->enix = findIndex(pwvanl, pwvanl->enri);
  }
  BEGIN_DEBUG(30)
    printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); 
  END_DEBUG
  
  /* beginning & end the right way round? */
  if((long)pwvanl->bgix > (long)pwvanl->enix ) {        
    temp = pwvanl->enix;
    pwvanl->enix = pwvanl->bgix;
    pwvanl->bgix = temp;
  }
  BEGIN_DEBUG(30)
    printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); 
  END_DEBUG  
  
  /* Beginning too close to the end of the array ? */
  if(pwvanl->nelm - pwvanl->bgix < MIN_SAMPLE_SIZE) {
    pwvanl->bgix = pwvanl->nelm - 1;
  }
  BEGIN_DEBUG(30)
    printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); 
  END_DEBUG  
  
  /* Region of interest big enough ? */   
  if(pwvanl->bgix - pwvanl->enix < MIN_SAMPLE_SIZE) {
    pwvanl->enix  = pwvanl->bgix;
  }
  BEGIN_DEBUG(30)
    printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); 
  END_DEBUG  
}
  
